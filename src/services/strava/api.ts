/* tslint:disable */
/* eslint-disable */
/**
 * Strava API v3
 * The [Swagger Playground](https://developers.strava.com/playground) is the easiest way to familiarize yourself with the Strava API by submitting HTTP requests and observing the responses before you write any client code. It will show what a response will look like with different endpoints depending on the authorization scope you receive from your athletes. To use the Playground, go to https://www.strava.com/settings/api and change your “Authorization Callback Domain” to developers.strava.com. Please note, we only support Swagger 2.0. There is a known issue where you can only select one scope at a time. For more information, please check the section “client code” at https://developers.strava.com/docs.
 *
 * The version of the OpenAPI document: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * A set of rolled-up statistics and totals for an athlete
 * @export
 * @interface ActivityStats
 */
export interface ActivityStats {
    /**
     * The longest distance ridden by the athlete.
     * @type {number}
     * @memberof ActivityStats
     */
    'biggest_ride_distance'?: number;
    /**
     * The highest climb ridden by the athlete.
     * @type {number}
     * @memberof ActivityStats
     */
    'biggest_climb_elevation_gain'?: number;
    /**
     * 
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    'recent_ride_totals'?: ActivityTotal;
    /**
     * 
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    'recent_run_totals'?: ActivityTotal;
    /**
     * 
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    'recent_swim_totals'?: ActivityTotal;
    /**
     * 
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    'ytd_ride_totals'?: ActivityTotal;
    /**
     * 
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    'ytd_run_totals'?: ActivityTotal;
    /**
     * 
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    'ytd_swim_totals'?: ActivityTotal;
    /**
     * 
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    'all_ride_totals'?: ActivityTotal;
    /**
     * 
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    'all_run_totals'?: ActivityTotal;
    /**
     * 
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    'all_swim_totals'?: ActivityTotal;
}
/**
 * A roll-up of metrics pertaining to a set of activities. Values are in seconds and meters.
 * @export
 * @interface ActivityTotal
 */
export interface ActivityTotal {
    /**
     * The number of activities considered in this total.
     * @type {number}
     * @memberof ActivityTotal
     */
    'count'?: number;
    /**
     * The total distance covered by the considered activities.
     * @type {number}
     * @memberof ActivityTotal
     */
    'distance'?: number;
    /**
     * The total moving time of the considered activities.
     * @type {number}
     * @memberof ActivityTotal
     */
    'moving_time'?: number;
    /**
     * The total elapsed time of the considered activities.
     * @type {number}
     * @memberof ActivityTotal
     */
    'elapsed_time'?: number;
    /**
     * The total elevation gain of the considered activities.
     * @type {number}
     * @memberof ActivityTotal
     */
    'elevation_gain'?: number;
    /**
     * The total number of achievements of the considered activities.
     * @type {number}
     * @memberof ActivityTotal
     */
    'achievement_count'?: number;
}
/**
 * An enumeration of the types an activity may have. Note that this enumeration does not include new sport types (e.g. MountainBikeRide, EMountainBikeRide), activities with these sport types will have the corresponding activity type (e.g. Ride for MountainBikeRide, EBikeRide for EMountainBikeRide)
 * @export
 * @enum {string}
 */

export const ActivityType = {
    AlpineSki: 'AlpineSki',
    BackcountrySki: 'BackcountrySki',
    Canoeing: 'Canoeing',
    Crossfit: 'Crossfit',
    EBikeRide: 'EBikeRide',
    Elliptical: 'Elliptical',
    Golf: 'Golf',
    Handcycle: 'Handcycle',
    Hike: 'Hike',
    IceSkate: 'IceSkate',
    InlineSkate: 'InlineSkate',
    Kayaking: 'Kayaking',
    Kitesurf: 'Kitesurf',
    NordicSki: 'NordicSki',
    Ride: 'Ride',
    RockClimbing: 'RockClimbing',
    RollerSki: 'RollerSki',
    Rowing: 'Rowing',
    Run: 'Run',
    Sail: 'Sail',
    Skateboard: 'Skateboard',
    Snowboard: 'Snowboard',
    Snowshoe: 'Snowshoe',
    Soccer: 'Soccer',
    StairStepper: 'StairStepper',
    StandUpPaddling: 'StandUpPaddling',
    Surfing: 'Surfing',
    Swim: 'Swim',
    Velomobile: 'Velomobile',
    VirtualRide: 'VirtualRide',
    VirtualRun: 'VirtualRun',
    Walk: 'Walk',
    WeightTraining: 'WeightTraining',
    Wheelchair: 'Wheelchair',
    Windsurf: 'Windsurf',
    Workout: 'Workout',
    Yoga: 'Yoga'
} as const;

export type ActivityType = typeof ActivityType[keyof typeof ActivityType];


/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * The unique identifier of this comment
     * @type {number}
     * @memberof Comment
     */
    'id'?: number;
    /**
     * The identifier of the activity this comment is related to
     * @type {number}
     * @memberof Comment
     */
    'activity_id'?: number;
    /**
     * The content of the comment
     * @type {string}
     * @memberof Comment
     */
    'text'?: string;
    /**
     * 
     * @type {SummaryAthlete}
     * @memberof Comment
     */
    'athlete'?: SummaryAthlete;
    /**
     * The time at which this comment was created.
     * @type {string}
     * @memberof Comment
     */
    'created_at'?: string;
}
/**
 * 
 * @export
 * @interface DetailedActivity
 */
export interface DetailedActivity {
    /**
     * The unique identifier of the activity
     * @type {number}
     * @memberof DetailedActivity
     */
    'id'?: number;
    /**
     * The identifier provided at upload time
     * @type {string}
     * @memberof DetailedActivity
     */
    'external_id'?: string;
    /**
     * The identifier of the upload that resulted in this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    'upload_id'?: number;
    /**
     * 
     * @type {MetaAthlete}
     * @memberof DetailedActivity
     */
    'athlete'?: MetaAthlete;
    /**
     * The name of the activity
     * @type {string}
     * @memberof DetailedActivity
     */
    'name'?: string;
    /**
     * The activity\'s distance, in meters
     * @type {number}
     * @memberof DetailedActivity
     */
    'distance'?: number;
    /**
     * The activity\'s moving time, in seconds
     * @type {number}
     * @memberof DetailedActivity
     */
    'moving_time'?: number;
    /**
     * The activity\'s elapsed time, in seconds
     * @type {number}
     * @memberof DetailedActivity
     */
    'elapsed_time'?: number;
    /**
     * The activity\'s total elevation gain.
     * @type {number}
     * @memberof DetailedActivity
     */
    'total_elevation_gain'?: number;
    /**
     * The activity\'s highest elevation, in meters
     * @type {number}
     * @memberof DetailedActivity
     */
    'elev_high'?: number;
    /**
     * The activity\'s lowest elevation, in meters
     * @type {number}
     * @memberof DetailedActivity
     */
    'elev_low'?: number;
    /**
     * 
     * @type {ActivityType}
     * @memberof DetailedActivity
     */
    'type'?: ActivityType;
    /**
     * 
     * @type {SportType}
     * @memberof DetailedActivity
     */
    'sport_type'?: SportType;
    /**
     * The time at which the activity was started.
     * @type {string}
     * @memberof DetailedActivity
     */
    'start_date'?: string;
    /**
     * The time at which the activity was started in the local timezone.
     * @type {string}
     * @memberof DetailedActivity
     */
    'start_date_local'?: string;
    /**
     * The timezone of the activity
     * @type {string}
     * @memberof DetailedActivity
     */
    'timezone'?: string;
    /**
     * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
     * @type {Array<number>}
     * @memberof DetailedActivity
     */
    'start_latlng'?: Array<number>;
    /**
     * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
     * @type {Array<number>}
     * @memberof DetailedActivity
     */
    'end_latlng'?: Array<number>;
    /**
     * The number of achievements gained during this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    'achievement_count'?: number;
    /**
     * The number of kudos given for this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    'kudos_count'?: number;
    /**
     * The number of comments for this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    'comment_count'?: number;
    /**
     * The number of athletes for taking part in a group activity
     * @type {number}
     * @memberof DetailedActivity
     */
    'athlete_count'?: number;
    /**
     * The number of Instagram photos for this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    'photo_count'?: number;
    /**
     * The number of Instagram and Strava photos for this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    'total_photo_count'?: number;
    /**
     * 
     * @type {PolylineMap}
     * @memberof DetailedActivity
     */
    'map'?: PolylineMap;
    /**
     * Whether this activity was recorded on a training machine
     * @type {boolean}
     * @memberof DetailedActivity
     */
    'trainer'?: boolean;
    /**
     * Whether this activity is a commute
     * @type {boolean}
     * @memberof DetailedActivity
     */
    'commute'?: boolean;
    /**
     * Whether this activity was created manually
     * @type {boolean}
     * @memberof DetailedActivity
     */
    'manual'?: boolean;
    /**
     * Whether this activity is private
     * @type {boolean}
     * @memberof DetailedActivity
     */
    'private'?: boolean;
    /**
     * Whether this activity is flagged
     * @type {boolean}
     * @memberof DetailedActivity
     */
    'flagged'?: boolean;
    /**
     * The activity\'s workout type
     * @type {number}
     * @memberof DetailedActivity
     */
    'workout_type'?: number;
    /**
     * The unique identifier of the upload in string format
     * @type {string}
     * @memberof DetailedActivity
     */
    'upload_id_str'?: string;
    /**
     * The activity\'s average speed, in meters per second
     * @type {number}
     * @memberof DetailedActivity
     */
    'average_speed'?: number;
    /**
     * The activity\'s max speed, in meters per second
     * @type {number}
     * @memberof DetailedActivity
     */
    'max_speed'?: number;
    /**
     * Whether the logged-in athlete has kudoed this activity
     * @type {boolean}
     * @memberof DetailedActivity
     */
    'has_kudoed'?: boolean;
    /**
     * Whether the activity is muted
     * @type {boolean}
     * @memberof DetailedActivity
     */
    'hide_from_home'?: boolean;
    /**
     * The id of the gear for the activity
     * @type {string}
     * @memberof DetailedActivity
     */
    'gear_id'?: string;
    /**
     * The total work done in kilojoules during this activity. Rides only
     * @type {number}
     * @memberof DetailedActivity
     */
    'kilojoules'?: number;
    /**
     * Average power output in watts during this activity. Rides only
     * @type {number}
     * @memberof DetailedActivity
     */
    'average_watts'?: number;
    /**
     * Whether the watts are from a power meter, false if estimated
     * @type {boolean}
     * @memberof DetailedActivity
     */
    'device_watts'?: boolean;
    /**
     * Rides with power meter data only
     * @type {number}
     * @memberof DetailedActivity
     */
    'max_watts'?: number;
    /**
     * Similar to Normalized Power. Rides with power meter data only
     * @type {number}
     * @memberof DetailedActivity
     */
    'weighted_average_watts'?: number;
    /**
     * The description of the activity
     * @type {string}
     * @memberof DetailedActivity
     */
    'description'?: string;
    /**
     * 
     * @type {PhotosSummary}
     * @memberof DetailedActivity
     */
    'photos'?: PhotosSummary;
    /**
     * 
     * @type {SummaryGear}
     * @memberof DetailedActivity
     */
    'gear'?: SummaryGear;
    /**
     * The number of kilocalories consumed during this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    'calories'?: number;
    /**
     * 
     * @type {Array<DetailedSegmentEffort>}
     * @memberof DetailedActivity
     */
    'segment_efforts'?: Array<DetailedSegmentEffort>;
    /**
     * The name of the device used to record the activity
     * @type {string}
     * @memberof DetailedActivity
     */
    'device_name'?: string;
    /**
     * The token used to embed a Strava activity
     * @type {string}
     * @memberof DetailedActivity
     */
    'embed_token'?: string;
    /**
     * The splits of this activity in metric units (for runs)
     * @type {Array<Split>}
     * @memberof DetailedActivity
     */
    'splits_metric'?: Array<Split>;
    /**
     * The splits of this activity in imperial units (for runs)
     * @type {Array<Split>}
     * @memberof DetailedActivity
     */
    'splits_standard'?: Array<Split>;
    /**
     * 
     * @type {Array<Lap>}
     * @memberof DetailedActivity
     */
    'laps'?: Array<Lap>;
    /**
     * 
     * @type {Array<DetailedSegmentEffort>}
     * @memberof DetailedActivity
     */
    'best_efforts'?: Array<DetailedSegmentEffort>;
}


/**
 * 
 * @export
 * @interface DetailedAthlete
 */
export interface DetailedAthlete {
    /**
     * The unique identifier of the athlete
     * @type {number}
     * @memberof DetailedAthlete
     */
    'id'?: number;
    /**
     * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof DetailedAthlete
     */
    'resource_state'?: number;
    /**
     * The athlete\'s first name.
     * @type {string}
     * @memberof DetailedAthlete
     */
    'firstname'?: string;
    /**
     * The athlete\'s last name.
     * @type {string}
     * @memberof DetailedAthlete
     */
    'lastname'?: string;
    /**
     * URL to a 62x62 pixel profile picture.
     * @type {string}
     * @memberof DetailedAthlete
     */
    'profile_medium'?: string;
    /**
     * URL to a 124x124 pixel profile picture.
     * @type {string}
     * @memberof DetailedAthlete
     */
    'profile'?: string;
    /**
     * The athlete\'s city.
     * @type {string}
     * @memberof DetailedAthlete
     */
    'city'?: string;
    /**
     * The athlete\'s state or geographical region.
     * @type {string}
     * @memberof DetailedAthlete
     */
    'state'?: string;
    /**
     * The athlete\'s country.
     * @type {string}
     * @memberof DetailedAthlete
     */
    'country'?: string;
    /**
     * The athlete\'s sex.
     * @type {string}
     * @memberof DetailedAthlete
     */
    'sex'?: DetailedAthleteSexEnum;
    /**
     * Deprecated.  Use summit field instead. Whether the athlete has any Summit subscription.
     * @type {boolean}
     * @memberof DetailedAthlete
     */
    'premium'?: boolean;
    /**
     * Whether the athlete has any Summit subscription.
     * @type {boolean}
     * @memberof DetailedAthlete
     */
    'summit'?: boolean;
    /**
     * The time at which the athlete was created.
     * @type {string}
     * @memberof DetailedAthlete
     */
    'created_at'?: string;
    /**
     * The time at which the athlete was last updated.
     * @type {string}
     * @memberof DetailedAthlete
     */
    'updated_at'?: string;
    /**
     * The athlete\'s follower count.
     * @type {number}
     * @memberof DetailedAthlete
     */
    'follower_count'?: number;
    /**
     * The athlete\'s friend count.
     * @type {number}
     * @memberof DetailedAthlete
     */
    'friend_count'?: number;
    /**
     * The athlete\'s preferred unit system.
     * @type {string}
     * @memberof DetailedAthlete
     */
    'measurement_preference'?: DetailedAthleteMeasurementPreferenceEnum;
    /**
     * The athlete\'s FTP (Functional Threshold Power).
     * @type {number}
     * @memberof DetailedAthlete
     */
    'ftp'?: number;
    /**
     * The athlete\'s weight.
     * @type {number}
     * @memberof DetailedAthlete
     */
    'weight'?: number;
    /**
     * The athlete\'s clubs.
     * @type {Array<SummaryClub>}
     * @memberof DetailedAthlete
     */
    'clubs'?: Array<SummaryClub>;
    /**
     * The athlete\'s bikes.
     * @type {Array<SummaryGear>}
     * @memberof DetailedAthlete
     */
    'bikes'?: Array<SummaryGear>;
    /**
     * The athlete\'s shoes.
     * @type {Array<SummaryGear>}
     * @memberof DetailedAthlete
     */
    'shoes'?: Array<SummaryGear>;
}

export const DetailedAthleteSexEnum = {
    M: 'M',
    F: 'F'
} as const;

export type DetailedAthleteSexEnum = typeof DetailedAthleteSexEnum[keyof typeof DetailedAthleteSexEnum];
export const DetailedAthleteMeasurementPreferenceEnum = {
    Feet: 'feet',
    Meters: 'meters'
} as const;

export type DetailedAthleteMeasurementPreferenceEnum = typeof DetailedAthleteMeasurementPreferenceEnum[keyof typeof DetailedAthleteMeasurementPreferenceEnum];

/**
 * 
 * @export
 * @interface DetailedSegmentEffort
 */
export interface DetailedSegmentEffort {
    /**
     * The unique identifier of this effort
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    'id'?: number;
    /**
     * The unique identifier of the activity related to this effort
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    'activity_id'?: number;
    /**
     * The effort\'s elapsed time
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    'elapsed_time'?: number;
    /**
     * The time at which the effort was started.
     * @type {string}
     * @memberof DetailedSegmentEffort
     */
    'start_date'?: string;
    /**
     * The time at which the effort was started in the local timezone.
     * @type {string}
     * @memberof DetailedSegmentEffort
     */
    'start_date_local'?: string;
    /**
     * The effort\'s distance in meters
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    'distance'?: number;
    /**
     * Whether this effort is the current best on the leaderboard
     * @type {boolean}
     * @memberof DetailedSegmentEffort
     */
    'is_kom'?: boolean;
    /**
     * The name of the segment on which this effort was performed
     * @type {string}
     * @memberof DetailedSegmentEffort
     */
    'name'?: string;
    /**
     * 
     * @type {MetaActivity}
     * @memberof DetailedSegmentEffort
     */
    'activity'?: MetaActivity;
    /**
     * 
     * @type {MetaAthlete}
     * @memberof DetailedSegmentEffort
     */
    'athlete'?: MetaAthlete;
    /**
     * The effort\'s moving time
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    'moving_time'?: number;
    /**
     * The start index of this effort in its activity\'s stream
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    'start_index'?: number;
    /**
     * The end index of this effort in its activity\'s stream
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    'end_index'?: number;
    /**
     * The effort\'s average cadence
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    'average_cadence'?: number;
    /**
     * The average wattage of this effort
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    'average_watts'?: number;
    /**
     * For riding efforts, whether the wattage was reported by a dedicated recording device
     * @type {boolean}
     * @memberof DetailedSegmentEffort
     */
    'device_watts'?: boolean;
    /**
     * The heart heart rate of the athlete during this effort
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    'average_heartrate'?: number;
    /**
     * The maximum heart rate of the athlete during this effort
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    'max_heartrate'?: number;
    /**
     * 
     * @type {SummarySegment}
     * @memberof DetailedSegmentEffort
     */
    'segment'?: SummarySegment;
    /**
     * The rank of the effort on the global leaderboard if it belongs in the top 10 at the time of upload
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    'kom_rank'?: number;
    /**
     * The rank of the effort on the athlete\'s leaderboard if it belongs in the top 3 at the time of upload
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    'pr_rank'?: number;
    /**
     * Whether this effort should be hidden when viewed within an activity
     * @type {boolean}
     * @memberof DetailedSegmentEffort
     */
    'hidden'?: boolean;
}
/**
 * Encapsulates the errors that may be returned from the API.
 * @export
 * @interface Fault
 */
export interface Fault {
    /**
     * The set of specific errors associated with this fault, if any.
     * @type {Array<Error>}
     * @memberof Fault
     */
    'errors'?: Array<Error>;
    /**
     * The message of the fault.
     * @type {string}
     * @memberof Fault
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Lap
 */
export interface Lap {
    /**
     * The unique identifier of this lap
     * @type {number}
     * @memberof Lap
     */
    'id'?: number;
    /**
     * 
     * @type {MetaActivity}
     * @memberof Lap
     */
    'activity'?: MetaActivity;
    /**
     * 
     * @type {MetaAthlete}
     * @memberof Lap
     */
    'athlete'?: MetaAthlete;
    /**
     * The lap\'s average cadence
     * @type {number}
     * @memberof Lap
     */
    'average_cadence'?: number;
    /**
     * The lap\'s average speed
     * @type {number}
     * @memberof Lap
     */
    'average_speed'?: number;
    /**
     * The lap\'s distance, in meters
     * @type {number}
     * @memberof Lap
     */
    'distance'?: number;
    /**
     * The lap\'s elapsed time, in seconds
     * @type {number}
     * @memberof Lap
     */
    'elapsed_time'?: number;
    /**
     * The start index of this effort in its activity\'s stream
     * @type {number}
     * @memberof Lap
     */
    'start_index'?: number;
    /**
     * The end index of this effort in its activity\'s stream
     * @type {number}
     * @memberof Lap
     */
    'end_index'?: number;
    /**
     * The index of this lap in the activity it belongs to
     * @type {number}
     * @memberof Lap
     */
    'lap_index'?: number;
    /**
     * The maximum speed of this lat, in meters per second
     * @type {number}
     * @memberof Lap
     */
    'max_speed'?: number;
    /**
     * The lap\'s moving time, in seconds
     * @type {number}
     * @memberof Lap
     */
    'moving_time'?: number;
    /**
     * The name of the lap
     * @type {string}
     * @memberof Lap
     */
    'name'?: string;
    /**
     * The athlete\'s pace zone during this lap
     * @type {number}
     * @memberof Lap
     */
    'pace_zone'?: number;
    /**
     * 
     * @type {number}
     * @memberof Lap
     */
    'split'?: number;
    /**
     * The time at which the lap was started.
     * @type {string}
     * @memberof Lap
     */
    'start_date'?: string;
    /**
     * The time at which the lap was started in the local timezone.
     * @type {string}
     * @memberof Lap
     */
    'start_date_local'?: string;
    /**
     * The elevation gain of this lap, in meters
     * @type {number}
     * @memberof Lap
     */
    'total_elevation_gain'?: number;
}
/**
 * 
 * @export
 * @interface MetaActivity
 */
export interface MetaActivity {
    /**
     * The unique identifier of the activity
     * @type {number}
     * @memberof MetaActivity
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface MetaAthlete
 */
export interface MetaAthlete {
    /**
     * The unique identifier of the athlete
     * @type {number}
     * @memberof MetaAthlete
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface MetaClub
 */
export interface MetaClub {
    /**
     * The club\'s unique identifier.
     * @type {number}
     * @memberof MetaClub
     */
    'id'?: number;
    /**
     * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof MetaClub
     */
    'resource_state'?: number;
    /**
     * The club\'s name.
     * @type {string}
     * @memberof MetaClub
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * The code associated with this error.
     * @type {string}
     * @memberof ModelError
     */
    'code'?: string;
    /**
     * The specific field or aspect of the resource associated with this error.
     * @type {string}
     * @memberof ModelError
     */
    'field'?: string;
    /**
     * The type of resource associated with this error.
     * @type {string}
     * @memberof ModelError
     */
    'resource'?: string;
}
/**
 * 
 * @export
 * @interface PhotosSummary
 */
export interface PhotosSummary {
    /**
     * The number of photos
     * @type {number}
     * @memberof PhotosSummary
     */
    'count'?: number;
    /**
     * 
     * @type {PhotosSummaryPrimary}
     * @memberof PhotosSummary
     */
    'primary'?: PhotosSummaryPrimary;
}
/**
 * 
 * @export
 * @interface PhotosSummaryPrimary
 */
export interface PhotosSummaryPrimary {
    /**
     * 
     * @type {number}
     * @memberof PhotosSummaryPrimary
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PhotosSummaryPrimary
     */
    'source'?: number;
    /**
     * 
     * @type {string}
     * @memberof PhotosSummaryPrimary
     */
    'unique_id'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PhotosSummaryPrimary
     */
    'urls'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface PolylineMap
 */
export interface PolylineMap {
    /**
     * The identifier of the map
     * @type {string}
     * @memberof PolylineMap
     */
    'id'?: string;
    /**
     * The polyline of the map, only returned on detailed representation of an object
     * @type {string}
     * @memberof PolylineMap
     */
    'polyline'?: string;
    /**
     * The summary polyline of the map
     * @type {string}
     * @memberof PolylineMap
     */
    'summary_polyline'?: string;
}
/**
 * 
 * @export
 * @interface Split
 */
export interface Split {
    /**
     * The average speed of this split, in meters per second
     * @type {number}
     * @memberof Split
     */
    'average_speed'?: number;
    /**
     * The distance of this split, in meters
     * @type {number}
     * @memberof Split
     */
    'distance'?: number;
    /**
     * The elapsed time of this split, in seconds
     * @type {number}
     * @memberof Split
     */
    'elapsed_time'?: number;
    /**
     * The elevation difference of this split, in meters
     * @type {number}
     * @memberof Split
     */
    'elevation_difference'?: number;
    /**
     * The pacing zone of this split
     * @type {number}
     * @memberof Split
     */
    'pace_zone'?: number;
    /**
     * The moving time of this split, in seconds
     * @type {number}
     * @memberof Split
     */
    'moving_time'?: number;
    /**
     * N/A
     * @type {number}
     * @memberof Split
     */
    'split'?: number;
}
/**
 * An enumeration of the sport types an activity may have. Distinct from ActivityType in that it has new types (e.g. MountainBikeRide)
 * @export
 * @enum {string}
 */

export const SportType = {
    AlpineSki: 'AlpineSki',
    BackcountrySki: 'BackcountrySki',
    Badminton: 'Badminton',
    Canoeing: 'Canoeing',
    Crossfit: 'Crossfit',
    EBikeRide: 'EBikeRide',
    Elliptical: 'Elliptical',
    EMountainBikeRide: 'EMountainBikeRide',
    Golf: 'Golf',
    GravelRide: 'GravelRide',
    Handcycle: 'Handcycle',
    HighIntensityIntervalTraining: 'HighIntensityIntervalTraining',
    Hike: 'Hike',
    IceSkate: 'IceSkate',
    InlineSkate: 'InlineSkate',
    Kayaking: 'Kayaking',
    Kitesurf: 'Kitesurf',
    MountainBikeRide: 'MountainBikeRide',
    NordicSki: 'NordicSki',
    Pickleball: 'Pickleball',
    Pilates: 'Pilates',
    Racquetball: 'Racquetball',
    Ride: 'Ride',
    RockClimbing: 'RockClimbing',
    RollerSki: 'RollerSki',
    Rowing: 'Rowing',
    Run: 'Run',
    Sail: 'Sail',
    Skateboard: 'Skateboard',
    Snowboard: 'Snowboard',
    Snowshoe: 'Snowshoe',
    Soccer: 'Soccer',
    Squash: 'Squash',
    StairStepper: 'StairStepper',
    StandUpPaddling: 'StandUpPaddling',
    Surfing: 'Surfing',
    Swim: 'Swim',
    TableTennis: 'TableTennis',
    Tennis: 'Tennis',
    TrailRun: 'TrailRun',
    Velomobile: 'Velomobile',
    VirtualRide: 'VirtualRide',
    VirtualRow: 'VirtualRow',
    VirtualRun: 'VirtualRun',
    Walk: 'Walk',
    WeightTraining: 'WeightTraining',
    Wheelchair: 'Wheelchair',
    Windsurf: 'Windsurf',
    Workout: 'Workout',
    Yoga: 'Yoga'
} as const;

export type SportType = typeof SportType[keyof typeof SportType];


/**
 * 
 * @export
 * @interface SummaryActivity
 */
export interface SummaryActivity {
    /**
     * The unique identifier of the activity
     * @type {number}
     * @memberof SummaryActivity
     */
    'id'?: number;
    /**
     * The identifier provided at upload time
     * @type {string}
     * @memberof SummaryActivity
     */
    'external_id'?: string;
    /**
     * The identifier of the upload that resulted in this activity
     * @type {number}
     * @memberof SummaryActivity
     */
    'upload_id'?: number;
    /**
     * 
     * @type {MetaAthlete}
     * @memberof SummaryActivity
     */
    'athlete'?: MetaAthlete;
    /**
     * The name of the activity
     * @type {string}
     * @memberof SummaryActivity
     */
    'name'?: string;
    /**
     * The activity\'s distance, in meters
     * @type {number}
     * @memberof SummaryActivity
     */
    'distance'?: number;
    /**
     * The activity\'s moving time, in seconds
     * @type {number}
     * @memberof SummaryActivity
     */
    'moving_time'?: number;
    /**
     * The activity\'s elapsed time, in seconds
     * @type {number}
     * @memberof SummaryActivity
     */
    'elapsed_time'?: number;
    /**
     * The activity\'s total elevation gain.
     * @type {number}
     * @memberof SummaryActivity
     */
    'total_elevation_gain'?: number;
    /**
     * The activity\'s highest elevation, in meters
     * @type {number}
     * @memberof SummaryActivity
     */
    'elev_high'?: number;
    /**
     * The activity\'s lowest elevation, in meters
     * @type {number}
     * @memberof SummaryActivity
     */
    'elev_low'?: number;
    /**
     * 
     * @type {ActivityType}
     * @memberof SummaryActivity
     */
    'type'?: ActivityType;
    /**
     * 
     * @type {SportType}
     * @memberof SummaryActivity
     */
    'sport_type'?: SportType;
    /**
     * The time at which the activity was started.
     * @type {string}
     * @memberof SummaryActivity
     */
    'start_date'?: string;
    /**
     * The time at which the activity was started in the local timezone.
     * @type {string}
     * @memberof SummaryActivity
     */
    'start_date_local'?: string;
    /**
     * The timezone of the activity
     * @type {string}
     * @memberof SummaryActivity
     */
    'timezone'?: string;
    /**
     * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
     * @type {Array<number>}
     * @memberof SummaryActivity
     */
    'start_latlng'?: Array<number>;
    /**
     * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
     * @type {Array<number>}
     * @memberof SummaryActivity
     */
    'end_latlng'?: Array<number>;
    /**
     * The number of achievements gained during this activity
     * @type {number}
     * @memberof SummaryActivity
     */
    'achievement_count'?: number;
    /**
     * The number of kudos given for this activity
     * @type {number}
     * @memberof SummaryActivity
     */
    'kudos_count'?: number;
    /**
     * The number of comments for this activity
     * @type {number}
     * @memberof SummaryActivity
     */
    'comment_count'?: number;
    /**
     * The number of athletes for taking part in a group activity
     * @type {number}
     * @memberof SummaryActivity
     */
    'athlete_count'?: number;
    /**
     * The number of Instagram photos for this activity
     * @type {number}
     * @memberof SummaryActivity
     */
    'photo_count'?: number;
    /**
     * The number of Instagram and Strava photos for this activity
     * @type {number}
     * @memberof SummaryActivity
     */
    'total_photo_count'?: number;
    /**
     * 
     * @type {PolylineMap}
     * @memberof SummaryActivity
     */
    'map'?: PolylineMap;
    /**
     * Whether this activity was recorded on a training machine
     * @type {boolean}
     * @memberof SummaryActivity
     */
    'trainer'?: boolean;
    /**
     * Whether this activity is a commute
     * @type {boolean}
     * @memberof SummaryActivity
     */
    'commute'?: boolean;
    /**
     * Whether this activity was created manually
     * @type {boolean}
     * @memberof SummaryActivity
     */
    'manual'?: boolean;
    /**
     * Whether this activity is private
     * @type {boolean}
     * @memberof SummaryActivity
     */
    'private'?: boolean;
    /**
     * Whether this activity is flagged
     * @type {boolean}
     * @memberof SummaryActivity
     */
    'flagged'?: boolean;
    /**
     * The activity\'s workout type
     * @type {number}
     * @memberof SummaryActivity
     */
    'workout_type'?: number;
    /**
     * The unique identifier of the upload in string format
     * @type {string}
     * @memberof SummaryActivity
     */
    'upload_id_str'?: string;
    /**
     * The activity\'s average speed, in meters per second
     * @type {number}
     * @memberof SummaryActivity
     */
    'average_speed'?: number;
    /**
     * The activity\'s max speed, in meters per second
     * @type {number}
     * @memberof SummaryActivity
     */
    'max_speed'?: number;
    /**
     * Whether the logged-in athlete has kudoed this activity
     * @type {boolean}
     * @memberof SummaryActivity
     */
    'has_kudoed'?: boolean;
    /**
     * Whether the activity is muted
     * @type {boolean}
     * @memberof SummaryActivity
     */
    'hide_from_home'?: boolean;
    /**
     * The id of the gear for the activity
     * @type {string}
     * @memberof SummaryActivity
     */
    'gear_id'?: string;
    /**
     * The total work done in kilojoules during this activity. Rides only
     * @type {number}
     * @memberof SummaryActivity
     */
    'kilojoules'?: number;
    /**
     * Average power output in watts during this activity. Rides only
     * @type {number}
     * @memberof SummaryActivity
     */
    'average_watts'?: number;
    /**
     * Whether the watts are from a power meter, false if estimated
     * @type {boolean}
     * @memberof SummaryActivity
     */
    'device_watts'?: boolean;
    /**
     * Rides with power meter data only
     * @type {number}
     * @memberof SummaryActivity
     */
    'max_watts'?: number;
    /**
     * Similar to Normalized Power. Rides with power meter data only
     * @type {number}
     * @memberof SummaryActivity
     */
    'weighted_average_watts'?: number;
}


/**
 * 
 * @export
 * @interface SummaryAthlete
 */
export interface SummaryAthlete {
    /**
     * The unique identifier of the athlete
     * @type {number}
     * @memberof SummaryAthlete
     */
    'id'?: number;
    /**
     * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof SummaryAthlete
     */
    'resource_state'?: number;
    /**
     * The athlete\'s first name.
     * @type {string}
     * @memberof SummaryAthlete
     */
    'firstname'?: string;
    /**
     * The athlete\'s last name.
     * @type {string}
     * @memberof SummaryAthlete
     */
    'lastname'?: string;
    /**
     * URL to a 62x62 pixel profile picture.
     * @type {string}
     * @memberof SummaryAthlete
     */
    'profile_medium'?: string;
    /**
     * URL to a 124x124 pixel profile picture.
     * @type {string}
     * @memberof SummaryAthlete
     */
    'profile'?: string;
    /**
     * The athlete\'s city.
     * @type {string}
     * @memberof SummaryAthlete
     */
    'city'?: string;
    /**
     * The athlete\'s state or geographical region.
     * @type {string}
     * @memberof SummaryAthlete
     */
    'state'?: string;
    /**
     * The athlete\'s country.
     * @type {string}
     * @memberof SummaryAthlete
     */
    'country'?: string;
    /**
     * The athlete\'s sex.
     * @type {string}
     * @memberof SummaryAthlete
     */
    'sex'?: SummaryAthleteSexEnum;
    /**
     * Deprecated.  Use summit field instead. Whether the athlete has any Summit subscription.
     * @type {boolean}
     * @memberof SummaryAthlete
     */
    'premium'?: boolean;
    /**
     * Whether the athlete has any Summit subscription.
     * @type {boolean}
     * @memberof SummaryAthlete
     */
    'summit'?: boolean;
    /**
     * The time at which the athlete was created.
     * @type {string}
     * @memberof SummaryAthlete
     */
    'created_at'?: string;
    /**
     * The time at which the athlete was last updated.
     * @type {string}
     * @memberof SummaryAthlete
     */
    'updated_at'?: string;
}

export const SummaryAthleteSexEnum = {
    M: 'M',
    F: 'F'
} as const;

export type SummaryAthleteSexEnum = typeof SummaryAthleteSexEnum[keyof typeof SummaryAthleteSexEnum];

/**
 * 
 * @export
 * @interface SummaryClub
 */
export interface SummaryClub {
    /**
     * The club\'s unique identifier.
     * @type {number}
     * @memberof SummaryClub
     */
    'id'?: number;
    /**
     * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof SummaryClub
     */
    'resource_state'?: number;
    /**
     * The club\'s name.
     * @type {string}
     * @memberof SummaryClub
     */
    'name'?: string;
    /**
     * URL to a 60x60 pixel profile picture.
     * @type {string}
     * @memberof SummaryClub
     */
    'profile_medium'?: string;
    /**
     * URL to a ~1185x580 pixel cover photo.
     * @type {string}
     * @memberof SummaryClub
     */
    'cover_photo'?: string;
    /**
     * URL to a ~360x176  pixel cover photo.
     * @type {string}
     * @memberof SummaryClub
     */
    'cover_photo_small'?: string;
    /**
     * Deprecated. Prefer to use activity_types.
     * @type {string}
     * @memberof SummaryClub
     */
    'sport_type'?: SummaryClubSportTypeEnum;
    /**
     * The activity types that count for a club. This takes precedence over sport_type.
     * @type {Array<ActivityType>}
     * @memberof SummaryClub
     */
    'activity_types'?: Array<ActivityType>;
    /**
     * The club\'s city.
     * @type {string}
     * @memberof SummaryClub
     */
    'city'?: string;
    /**
     * The club\'s state or geographical region.
     * @type {string}
     * @memberof SummaryClub
     */
    'state'?: string;
    /**
     * The club\'s country.
     * @type {string}
     * @memberof SummaryClub
     */
    'country'?: string;
    /**
     * Whether the club is private.
     * @type {boolean}
     * @memberof SummaryClub
     */
    'private'?: boolean;
    /**
     * The club\'s member count.
     * @type {number}
     * @memberof SummaryClub
     */
    'member_count'?: number;
    /**
     * Whether the club is featured or not.
     * @type {boolean}
     * @memberof SummaryClub
     */
    'featured'?: boolean;
    /**
     * Whether the club is verified or not.
     * @type {boolean}
     * @memberof SummaryClub
     */
    'verified'?: boolean;
    /**
     * The club\'s vanity URL.
     * @type {string}
     * @memberof SummaryClub
     */
    'url'?: string;
}

export const SummaryClubSportTypeEnum = {
    Cycling: 'cycling',
    Running: 'running',
    Triathlon: 'triathlon',
    Other: 'other'
} as const;

export type SummaryClubSportTypeEnum = typeof SummaryClubSportTypeEnum[keyof typeof SummaryClubSportTypeEnum];

/**
 * 
 * @export
 * @interface SummaryGear
 */
export interface SummaryGear {
    /**
     * The gear\'s unique identifier.
     * @type {string}
     * @memberof SummaryGear
     */
    'id'?: string;
    /**
     * Resource state, indicates level of detail. Possible values: 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof SummaryGear
     */
    'resource_state'?: number;
    /**
     * Whether this gear\'s is the owner\'s default one.
     * @type {boolean}
     * @memberof SummaryGear
     */
    'primary'?: boolean;
    /**
     * The gear\'s name.
     * @type {string}
     * @memberof SummaryGear
     */
    'name'?: string;
    /**
     * The distance logged with this gear.
     * @type {number}
     * @memberof SummaryGear
     */
    'distance'?: number;
}
/**
 * 
 * @export
 * @interface SummaryPRSegmentEffort
 */
export interface SummaryPRSegmentEffort {
    /**
     * The unique identifier of the activity related to the PR effort.
     * @type {number}
     * @memberof SummaryPRSegmentEffort
     */
    'pr_activity_id'?: number;
    /**
     * The elapsed time ot the PR effort.
     * @type {number}
     * @memberof SummaryPRSegmentEffort
     */
    'pr_elapsed_time'?: number;
    /**
     * The time at which the PR effort was started.
     * @type {string}
     * @memberof SummaryPRSegmentEffort
     */
    'pr_date'?: string;
    /**
     * Number of efforts by the authenticated athlete on this segment.
     * @type {number}
     * @memberof SummaryPRSegmentEffort
     */
    'effort_count'?: number;
}
/**
 * 
 * @export
 * @interface SummarySegment
 */
export interface SummarySegment {
    /**
     * The unique identifier of this segment
     * @type {number}
     * @memberof SummarySegment
     */
    'id'?: number;
    /**
     * The name of this segment
     * @type {string}
     * @memberof SummarySegment
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SummarySegment
     */
    'activity_type'?: SummarySegmentActivityTypeEnum;
    /**
     * The segment\'s distance, in meters
     * @type {number}
     * @memberof SummarySegment
     */
    'distance'?: number;
    /**
     * The segment\'s average grade, in percents
     * @type {number}
     * @memberof SummarySegment
     */
    'average_grade'?: number;
    /**
     * The segments\'s maximum grade, in percents
     * @type {number}
     * @memberof SummarySegment
     */
    'maximum_grade'?: number;
    /**
     * The segments\'s highest elevation, in meters
     * @type {number}
     * @memberof SummarySegment
     */
    'elevation_high'?: number;
    /**
     * The segments\'s lowest elevation, in meters
     * @type {number}
     * @memberof SummarySegment
     */
    'elevation_low'?: number;
    /**
     * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
     * @type {Array<number>}
     * @memberof SummarySegment
     */
    'start_latlng'?: Array<number>;
    /**
     * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
     * @type {Array<number>}
     * @memberof SummarySegment
     */
    'end_latlng'?: Array<number>;
    /**
     * The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catégorie, 0 is uncategorized in climb_category.
     * @type {number}
     * @memberof SummarySegment
     */
    'climb_category'?: number;
    /**
     * The segments\'s city.
     * @type {string}
     * @memberof SummarySegment
     */
    'city'?: string;
    /**
     * The segments\'s state or geographical region.
     * @type {string}
     * @memberof SummarySegment
     */
    'state'?: string;
    /**
     * The segment\'s country.
     * @type {string}
     * @memberof SummarySegment
     */
    'country'?: string;
    /**
     * Whether this segment is private.
     * @type {boolean}
     * @memberof SummarySegment
     */
    'private'?: boolean;
    /**
     * 
     * @type {SummaryPRSegmentEffort}
     * @memberof SummarySegment
     */
    'athlete_pr_effort'?: SummaryPRSegmentEffort;
    /**
     * 
     * @type {SummarySegmentEffort}
     * @memberof SummarySegment
     */
    'athlete_segment_stats'?: SummarySegmentEffort;
}

export const SummarySegmentActivityTypeEnum = {
    Ride: 'Ride',
    Run: 'Run'
} as const;

export type SummarySegmentActivityTypeEnum = typeof SummarySegmentActivityTypeEnum[keyof typeof SummarySegmentActivityTypeEnum];

/**
 * 
 * @export
 * @interface SummarySegmentEffort
 */
export interface SummarySegmentEffort {
    /**
     * The unique identifier of this effort
     * @type {number}
     * @memberof SummarySegmentEffort
     */
    'id'?: number;
    /**
     * The unique identifier of the activity related to this effort
     * @type {number}
     * @memberof SummarySegmentEffort
     */
    'activity_id'?: number;
    /**
     * The effort\'s elapsed time
     * @type {number}
     * @memberof SummarySegmentEffort
     */
    'elapsed_time'?: number;
    /**
     * The time at which the effort was started.
     * @type {string}
     * @memberof SummarySegmentEffort
     */
    'start_date'?: string;
    /**
     * The time at which the effort was started in the local timezone.
     * @type {string}
     * @memberof SummarySegmentEffort
     */
    'start_date_local'?: string;
    /**
     * The effort\'s distance in meters
     * @type {number}
     * @memberof SummarySegmentEffort
     */
    'distance'?: number;
    /**
     * Whether this effort is the current best on the leaderboard
     * @type {boolean}
     * @memberof SummarySegmentEffort
     */
    'is_kom'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdatableActivity
 */
export interface UpdatableActivity {
    /**
     * Whether this activity is a commute
     * @type {boolean}
     * @memberof UpdatableActivity
     */
    'commute'?: boolean;
    /**
     * Whether this activity was recorded on a training machine
     * @type {boolean}
     * @memberof UpdatableActivity
     */
    'trainer'?: boolean;
    /**
     * Whether this activity is muted
     * @type {boolean}
     * @memberof UpdatableActivity
     */
    'hide_from_home'?: boolean;
    /**
     * The description of the activity
     * @type {string}
     * @memberof UpdatableActivity
     */
    'description'?: string;
    /**
     * The name of the activity
     * @type {string}
     * @memberof UpdatableActivity
     */
    'name'?: string;
    /**
     * 
     * @type {ActivityType}
     * @memberof UpdatableActivity
     */
    'type'?: ActivityType;
    /**
     * 
     * @type {SportType}
     * @memberof UpdatableActivity
     */
    'sport_type'?: SportType;
    /**
     * Identifier for the gear associated with the activity. ‘none’ clears gear from activity
     * @type {string}
     * @memberof UpdatableActivity
     */
    'gear_id'?: string;
}



/**
 * ActivitiesApi - axios parameter creator
 * @export
 */
export const ActivitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a manual activity for an athlete, requires activity:write scope.
         * @summary Create an Activity
         * @param {string} name The name of the activity.
         * @param {string} sportType Sport type of activity. For example - Run, MountainBikeRide, Ride, etc.
         * @param {string} startDateLocal ISO 8601 formatted date time.
         * @param {number} elapsedTime In seconds.
         * @param {string} [type] Type of activity. For example - Run, Ride etc.
         * @param {string} [description] Description of the activity.
         * @param {number} [distance] In meters.
         * @param {number} [trainer] Set to 1 to mark as a trainer activity.
         * @param {number} [commute] Set to 1 to mark as commute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivity: async (name: string, sportType: string, startDateLocal: string, elapsedTime: number, type?: string, description?: string, distance?: number, trainer?: number, commute?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createActivity', 'name', name)
            // verify required parameter 'sportType' is not null or undefined
            assertParamExists('createActivity', 'sportType', sportType)
            // verify required parameter 'startDateLocal' is not null or undefined
            assertParamExists('createActivity', 'startDateLocal', startDateLocal)
            // verify required parameter 'elapsedTime' is not null or undefined
            assertParamExists('createActivity', 'elapsedTime', elapsedTime)
            const localVarPath = `/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication strava_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "strava_oauth", [], configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.append('type', type as any);
            }
    
            if (sportType !== undefined) { 
                localVarFormParams.append('sport_type', sportType as any);
            }
    
            if (startDateLocal !== undefined) { 
                localVarFormParams.append('start_date_local', startDateLocal as any);
            }
    
            if (elapsedTime !== undefined) { 
                localVarFormParams.append('elapsed_time', elapsedTime as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (distance !== undefined) { 
                localVarFormParams.append('distance', distance as any);
            }
    
            if (trainer !== undefined) { 
                localVarFormParams.append('trainer', trainer as any);
            }
    
            if (commute !== undefined) { 
                localVarFormParams.append('commute', commute as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the given activity that is owned by the authenticated athlete. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary Get Activity
         * @param {number} id The identifier of the activity.
         * @param {boolean} [includeAllEfforts] To include all segments efforts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityById: async (id: number, includeAllEfforts?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getActivityById', 'id', id)
            const localVarPath = `/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "strava_oauth", [], configuration)

            if (includeAllEfforts !== undefined) {
                localVarQueryParameter['include_all_efforts'] = includeAllEfforts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the comments on the given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary List Activity Comments
         * @param {number} id The identifier of the activity.
         * @param {number} [page] Deprecated. Prefer to use after_cursor.
         * @param {number} [perPage] Deprecated. Prefer to use page_size.
         * @param {number} [pageSize] Number of items per page. Defaults to 30.
         * @param {string} [afterCursor] Cursor of the last item in the previous page of results, used to request the subsequent page of results.  When omitted, the first page of results is fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentsByActivityId: async (id: number, page?: number, perPage?: number, pageSize?: number, afterCursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCommentsByActivityId', 'id', id)
            const localVarPath = `/activities/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "strava_oauth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (afterCursor !== undefined) {
                localVarQueryParameter['after_cursor'] = afterCursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the activities of an athlete for a specific identifier. Requires activity:read. Only Me activities will be filtered out unless requested by a token with activity:read_all.
         * @summary List Athlete Activities
         * @param {number} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
         * @param {number} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteActivities: async (before?: number, after?: number, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/athlete/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "strava_oauth", [], configuration)

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the given activity that is owned by the authenticated athlete. Requires activity:write. Also requires activity:read_all in order to update Only Me activities
         * @summary Update Activity
         * @param {number} id The identifier of the activity.
         * @param {UpdatableActivity} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivityById: async (id: number, body?: UpdatableActivity, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateActivityById', 'id', id)
            const localVarPath = `/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "strava_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivitiesApi - functional programming interface
 * @export
 */
export const ActivitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a manual activity for an athlete, requires activity:write scope.
         * @summary Create an Activity
         * @param {string} name The name of the activity.
         * @param {string} sportType Sport type of activity. For example - Run, MountainBikeRide, Ride, etc.
         * @param {string} startDateLocal ISO 8601 formatted date time.
         * @param {number} elapsedTime In seconds.
         * @param {string} [type] Type of activity. For example - Run, Ride etc.
         * @param {string} [description] Description of the activity.
         * @param {number} [distance] In meters.
         * @param {number} [trainer] Set to 1 to mark as a trainer activity.
         * @param {number} [commute] Set to 1 to mark as commute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActivity(name: string, sportType: string, startDateLocal: string, elapsedTime: number, type?: string, description?: string, distance?: number, trainer?: number, commute?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedActivity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createActivity(name, sportType, startDateLocal, elapsedTime, type, description, distance, trainer, commute, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivitiesApi.createActivity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the given activity that is owned by the authenticated athlete. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary Get Activity
         * @param {number} id The identifier of the activity.
         * @param {boolean} [includeAllEfforts] To include all segments efforts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityById(id: number, includeAllEfforts?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedActivity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivityById(id, includeAllEfforts, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivitiesApi.getActivityById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the comments on the given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary List Activity Comments
         * @param {number} id The identifier of the activity.
         * @param {number} [page] Deprecated. Prefer to use after_cursor.
         * @param {number} [perPage] Deprecated. Prefer to use page_size.
         * @param {number} [pageSize] Number of items per page. Defaults to 30.
         * @param {string} [afterCursor] Cursor of the last item in the previous page of results, used to request the subsequent page of results.  When omitted, the first page of results is fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommentsByActivityId(id: number, page?: number, perPage?: number, pageSize?: number, afterCursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Comment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommentsByActivityId(id, page, perPage, pageSize, afterCursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivitiesApi.getCommentsByActivityId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the activities of an athlete for a specific identifier. Requires activity:read. Only Me activities will be filtered out unless requested by a token with activity:read_all.
         * @summary List Athlete Activities
         * @param {number} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
         * @param {number} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoggedInAthleteActivities(before?: number, after?: number, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SummaryActivity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoggedInAthleteActivities(before, after, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivitiesApi.getLoggedInAthleteActivities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the given activity that is owned by the authenticated athlete. Requires activity:write. Also requires activity:read_all in order to update Only Me activities
         * @summary Update Activity
         * @param {number} id The identifier of the activity.
         * @param {UpdatableActivity} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateActivityById(id: number, body?: UpdatableActivity, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedActivity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateActivityById(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivitiesApi.updateActivityById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActivitiesApi - factory interface
 * @export
 */
export const ActivitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivitiesApiFp(configuration)
    return {
        /**
         * Creates a manual activity for an athlete, requires activity:write scope.
         * @summary Create an Activity
         * @param {string} name The name of the activity.
         * @param {string} sportType Sport type of activity. For example - Run, MountainBikeRide, Ride, etc.
         * @param {string} startDateLocal ISO 8601 formatted date time.
         * @param {number} elapsedTime In seconds.
         * @param {string} [type] Type of activity. For example - Run, Ride etc.
         * @param {string} [description] Description of the activity.
         * @param {number} [distance] In meters.
         * @param {number} [trainer] Set to 1 to mark as a trainer activity.
         * @param {number} [commute] Set to 1 to mark as commute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivity(name: string, sportType: string, startDateLocal: string, elapsedTime: number, type?: string, description?: string, distance?: number, trainer?: number, commute?: number, options?: RawAxiosRequestConfig): AxiosPromise<DetailedActivity> {
            return localVarFp.createActivity(name, sportType, startDateLocal, elapsedTime, type, description, distance, trainer, commute, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the given activity that is owned by the authenticated athlete. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary Get Activity
         * @param {number} id The identifier of the activity.
         * @param {boolean} [includeAllEfforts] To include all segments efforts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityById(id: number, includeAllEfforts?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<DetailedActivity> {
            return localVarFp.getActivityById(id, includeAllEfforts, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the comments on the given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary List Activity Comments
         * @param {number} id The identifier of the activity.
         * @param {number} [page] Deprecated. Prefer to use after_cursor.
         * @param {number} [perPage] Deprecated. Prefer to use page_size.
         * @param {number} [pageSize] Number of items per page. Defaults to 30.
         * @param {string} [afterCursor] Cursor of the last item in the previous page of results, used to request the subsequent page of results.  When omitted, the first page of results is fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentsByActivityId(id: number, page?: number, perPage?: number, pageSize?: number, afterCursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Comment>> {
            return localVarFp.getCommentsByActivityId(id, page, perPage, pageSize, afterCursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the activities of an athlete for a specific identifier. Requires activity:read. Only Me activities will be filtered out unless requested by a token with activity:read_all.
         * @summary List Athlete Activities
         * @param {number} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
         * @param {number} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteActivities(before?: number, after?: number, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<SummaryActivity>> {
            return localVarFp.getLoggedInAthleteActivities(before, after, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the given activity that is owned by the authenticated athlete. Requires activity:write. Also requires activity:read_all in order to update Only Me activities
         * @summary Update Activity
         * @param {number} id The identifier of the activity.
         * @param {UpdatableActivity} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivityById(id: number, body?: UpdatableActivity, options?: RawAxiosRequestConfig): AxiosPromise<DetailedActivity> {
            return localVarFp.updateActivityById(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
export class ActivitiesApi extends BaseAPI {
    /**
     * Creates a manual activity for an athlete, requires activity:write scope.
     * @summary Create an Activity
     * @param {string} name The name of the activity.
     * @param {string} sportType Sport type of activity. For example - Run, MountainBikeRide, Ride, etc.
     * @param {string} startDateLocal ISO 8601 formatted date time.
     * @param {number} elapsedTime In seconds.
     * @param {string} [type] Type of activity. For example - Run, Ride etc.
     * @param {string} [description] Description of the activity.
     * @param {number} [distance] In meters.
     * @param {number} [trainer] Set to 1 to mark as a trainer activity.
     * @param {number} [commute] Set to 1 to mark as commute.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public createActivity(name: string, sportType: string, startDateLocal: string, elapsedTime: number, type?: string, description?: string, distance?: number, trainer?: number, commute?: number, options?: RawAxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).createActivity(name, sportType, startDateLocal, elapsedTime, type, description, distance, trainer, commute, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the given activity that is owned by the authenticated athlete. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary Get Activity
     * @param {number} id The identifier of the activity.
     * @param {boolean} [includeAllEfforts] To include all segments efforts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getActivityById(id: number, includeAllEfforts?: boolean, options?: RawAxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).getActivityById(id, includeAllEfforts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the comments on the given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary List Activity Comments
     * @param {number} id The identifier of the activity.
     * @param {number} [page] Deprecated. Prefer to use after_cursor.
     * @param {number} [perPage] Deprecated. Prefer to use page_size.
     * @param {number} [pageSize] Number of items per page. Defaults to 30.
     * @param {string} [afterCursor] Cursor of the last item in the previous page of results, used to request the subsequent page of results.  When omitted, the first page of results is fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getCommentsByActivityId(id: number, page?: number, perPage?: number, pageSize?: number, afterCursor?: string, options?: RawAxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).getCommentsByActivityId(id, page, perPage, pageSize, afterCursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the activities of an athlete for a specific identifier. Requires activity:read. Only Me activities will be filtered out unless requested by a token with activity:read_all.
     * @summary List Athlete Activities
     * @param {number} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
     * @param {number} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getLoggedInAthleteActivities(before?: number, after?: number, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).getLoggedInAthleteActivities(before, after, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the given activity that is owned by the authenticated athlete. Requires activity:write. Also requires activity:read_all in order to update Only Me activities
     * @summary Update Activity
     * @param {number} id The identifier of the activity.
     * @param {UpdatableActivity} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public updateActivityById(id: number, body?: UpdatableActivity, options?: RawAxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).updateActivityById(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AthletesApi - axios parameter creator
 * @export
 */
export const AthletesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the currently authenticated athlete. Tokens with profile:read_all scope will receive a detailed athlete representation; all others will receive a summary representation.
         * @summary Get Authenticated Athlete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthlete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/athlete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "strava_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the activity stats of an athlete. Only includes data from activities set to Everyone visibilty.
         * @summary Get Athlete Stats
         * @param {number} id The identifier of the athlete. Must match the authenticated athlete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStats', 'id', id)
            const localVarPath = `/athletes/{id}/stats`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "strava_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the currently authenticated athlete. Requires profile:write scope.
         * @summary Update Athlete
         * @param {number} weight The weight of the athlete in kilograms.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoggedInAthlete: async (weight: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'weight' is not null or undefined
            assertParamExists('updateLoggedInAthlete', 'weight', weight)
            const localVarPath = `/athlete`
                .replace(`{${"weight"}}`, encodeURIComponent(String(weight)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "strava_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AthletesApi - functional programming interface
 * @export
 */
export const AthletesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AthletesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the currently authenticated athlete. Tokens with profile:read_all scope will receive a detailed athlete representation; all others will receive a summary representation.
         * @summary Get Authenticated Athlete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoggedInAthlete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedAthlete>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoggedInAthlete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AthletesApi.getLoggedInAthlete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the activity stats of an athlete. Only includes data from activities set to Everyone visibilty.
         * @summary Get Athlete Stats
         * @param {number} id The identifier of the athlete. Must match the authenticated athlete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AthletesApi.getStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the currently authenticated athlete. Requires profile:write scope.
         * @summary Update Athlete
         * @param {number} weight The weight of the athlete in kilograms.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLoggedInAthlete(weight: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedAthlete>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLoggedInAthlete(weight, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AthletesApi.updateLoggedInAthlete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AthletesApi - factory interface
 * @export
 */
export const AthletesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AthletesApiFp(configuration)
    return {
        /**
         * Returns the currently authenticated athlete. Tokens with profile:read_all scope will receive a detailed athlete representation; all others will receive a summary representation.
         * @summary Get Authenticated Athlete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthlete(options?: RawAxiosRequestConfig): AxiosPromise<DetailedAthlete> {
            return localVarFp.getLoggedInAthlete(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the activity stats of an athlete. Only includes data from activities set to Everyone visibilty.
         * @summary Get Athlete Stats
         * @param {number} id The identifier of the athlete. Must match the authenticated athlete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ActivityStats> {
            return localVarFp.getStats(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the currently authenticated athlete. Requires profile:write scope.
         * @summary Update Athlete
         * @param {number} weight The weight of the athlete in kilograms.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoggedInAthlete(weight: number, options?: RawAxiosRequestConfig): AxiosPromise<DetailedAthlete> {
            return localVarFp.updateLoggedInAthlete(weight, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AthletesApi - object-oriented interface
 * @export
 * @class AthletesApi
 * @extends {BaseAPI}
 */
export class AthletesApi extends BaseAPI {
    /**
     * Returns the currently authenticated athlete. Tokens with profile:read_all scope will receive a detailed athlete representation; all others will receive a summary representation.
     * @summary Get Authenticated Athlete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AthletesApi
     */
    public getLoggedInAthlete(options?: RawAxiosRequestConfig) {
        return AthletesApiFp(this.configuration).getLoggedInAthlete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the activity stats of an athlete. Only includes data from activities set to Everyone visibilty.
     * @summary Get Athlete Stats
     * @param {number} id The identifier of the athlete. Must match the authenticated athlete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AthletesApi
     */
    public getStats(id: number, options?: RawAxiosRequestConfig) {
        return AthletesApiFp(this.configuration).getStats(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the currently authenticated athlete. Requires profile:write scope.
     * @summary Update Athlete
     * @param {number} weight The weight of the athlete in kilograms.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AthletesApi
     */
    public updateLoggedInAthlete(weight: number, options?: RawAxiosRequestConfig) {
        return AthletesApiFp(this.configuration).updateLoggedInAthlete(weight, options).then((request) => request(this.axios, this.basePath));
    }
}



